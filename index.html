<!DOCTYPE html>
<script src="./nerdamer/all.min.js"></script>  <!-- assuming you've saved the file in the root -->
<html>
<body>
  <img id="imgHat" style="display: none" src="hat.png">
  <img id="imgHat2" style="display: none" src="hat2.png">
  <img id="imgIntroDesk" style="display: none" src="intro-desk.png">
  <img id="imgLevelNotebook" style="display: none" src="levelNotebook.jpg">

  <canvas id="myCanvas" style="position:absolute" width="100%" height="100" style="border:1px solid #000000;">
    Your browser does not support the HTML canvas tag.
  </canvas>
  <div style="position:absolute">
    <button type="button" onclick='console.log(123);localStorage.setItem("global", JSON.stringify(initState))'>Click Me!</button>
  </div>

<style>
  html, body {
    margin: 0;
    overflow:hidden;
  }
</style>

<script>
  // Reset backup:
  //localStorage.setItem("global", JSON.stringify(initState))
  function min(a,b){return a>b?b:a;}
  function toUnit(x,y, xn,yn, distFrom0) { // Point 1, and point 2
    const temp = Math.sqrt(x*x+y*y);
    p=[xn,yn];
    if (Math.abs(temp) > distFrom0) {
      p[0] = x/temp;
      p[1] = y/temp;
    }
    return p
  }
  function dist(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
  }

  let c = document.getElementById("myCanvas");
  let ctx = c.getContext("2d");
  let speed = 4
  let button = {}
  let actionCooldown = 1;

  ctx.font = "50px Consolas"; // Sets text
  let weapons = [
    {from: "+1"  , math:"+1", apply: x => '('+x+')+1'  },
    {from: "-1"  , math:"-1", apply: x => '('+x+')-1'  },
    {from: "sqrt", math:"²√", apply: x => 'sqrt('+x+')'},
    {from: "^2"  , math:"²" , apply: x => '('+x+')^2'  },
  ]

  // ---------------
  // State variables
  // ---------------
  let initState = {
    startTime: Date.now()/1000,
    p1: {
      x:1,y:2,
      dirX:1,dirY:0,
      timeAtLastAction:-Infinity,
      weapon: null,
      lives:3,
    },
    p2: {
      x:1,y:2,
      dirX:1,dirY:0,
      timeAtLastAction:-Infinity,
      weapon: null,
      lives:3,
    },
    enemies: [
      {x:200, y:0, math: "1", speed:2},
    ],
    bullets: [],
    pickups: [
      {x: 10, y: 50, weapon: {from: "sqrt", math:"²√", apply: x => 'sqrt('+x+')'}}
    ],
  }
  isIntro = false;
  let global = localStorage.getItem("global");
  if(!global) {
    isIntro = true;
    global = initState;
  } else {
    isIntro = false;
    global = JSON.parse(global);
  }

  let p1 = global.p1;
  let p2 = global.p2;
  let bullets = global.bullets;
  let pickups = global.pickups;

  // ---------------
  // Gamepad
  // ---------------
  let gamepads = [];
  window.addEventListener("gamepadconnected", e=>{
    if (gamepads.length > 2) return;
    console.log(
      "Gamepad connected at index %d: %s. %d buttons, %d axes.",
      e.gamepad.index,
      e.gamepad.id,
      e.gamepad.buttons.length,
      e.gamepad.axes.length,
    );
    gamepads = gamepads.concat(navigator.getGamepads()[e.gamepad.index]);
  });

  // ---------------
  // Game logic
  // ---------------
  function Draw() {
    const timestamp = Date.now()/1000
    let s = min(window.innerWidth, window.innerHeight); // s for Size
    let pickupDistance = 0.3*s/2;
    ctx.canvas.height = window.innerHeight;
    ctx.canvas.width  = window.innerWidth;

    // --------------- //
    // Environment     //
    // --------------- //
    scale = 2*(Math.min(timestamp-global.startTime,4))
    eyeX = 194
    eyeY = 170

    ctx.drawImage(imgIntroDesk,

      // scale the eyeX offset by the scaling factor
      // and then push the image horizontally to center canvas
      -eyeX*scale + s/2,

      // scale the eyeY offset by the scaling factor
      // and then push the image vertically to center canvas
      -eyeY*scale + s/2,

      // scale whole image by the scaling factor
      s*scale,
      s*scale
    );

    ctx.drawImage(imgLevelNotebook, -(eyeX-170)*scale + s/2, -(eyeY-140)*scale + s/2, s*scale*0.20, s*scale*0.20);

    if (isIntro){
      isIntro = global.startTime+4 > timestamp;
      requestAnimationFrame(Draw);
      return;
    }

    pickups.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.x+s/2, b.y+s/2, 20, 0, 2 * Math.PI);
      ctx.stroke();

      if (b.weapon){
        ctx.font = "20px Consolas"; // Sets text
        ctx.fillText(b.weapon.math, b.x+(s-25)/2, b.y+(s+15)/2)
        ctx.font = "50px Consolas"; // Sets text
      }
    })


    // --------------- //
    // Player Movement //
    // --------------- //
    p1.dirX = !!button['ArrowRight']-!!button['ArrowLeft'];
    p1.dirY = !!button['ArrowDown' ]-!!button['ArrowUp'  ];
    let v1 = toUnit(p1.dirX, p1.dirY, 0, 0, 0)
    p1.dirX = v1[0];
    p1.dirY = v1[1];

    p1.x += speed*p1.dirX;
    p1.y += speed*p1.dirY;

    let v2 = toUnit(
      !!button['d']-!!button['a'],
      !!button['s']-!!button['w'],
      0, 0, 0
    )
    p2.dirX = v2[0];
    p2.dirY = v2[1];

    p2.x += speed*p2.dirX;
    p2.y += speed*p2.dirY;

    let swapWeaponPlayer = [false, false];

    // Shoot logic
    if (p1.weapon && button['Enter'] && actionCooldown < timestamp-p1.timeAtLastAction){
      p1.timeAtLastAction = timestamp;

      bullets = bullets.concat({x:p1.x, y:p1.y, dirX:p1.dirX, dirY:p1.dirY, math:p1.weapon});
    }
    if (p2.weapon && button[' '] && actionCooldown < timestamp-p2.timeAtLastAction) {
      p2.timeAtLastAction = timestamp;

      bullets = bullets.concat({x:p2.x, y:p2.y, dirX:p2.dirX, dirY:p2.dirY, math:p2.weapon});
    }

    if (button['p']) {
      swapWeaponPlayer[0] = true;
    }
    if (button['q']) {
      swapWeaponPlayer[1] = true;
    }

    //e.math = nerdamer(p1.weapon.apply(e.math.toString()));
    //e.math = nerdamer(p2.weapon.apply(e.math.toString()));


    // ------------- //
    // Gamepad stuff //
    // ------------- //
    for(let i=0; i<2; i++){
      let gamepad = gamepads[i];
      if (gamepad) {
        player = [p1, p2][i];
        const sign1 = Math.sign(gamepad.axes[0]);
        const sign2 = Math.sign(gamepad.axes[1]);

        player.x += speed*sign1*Math.floor(Math.abs(gamepad.axes[0])*7)*(1/7)
        player.y += speed*sign2*Math.floor(Math.abs(gamepad.axes[1])*7)*(1/7)

        swapWeaponPlayer[i] = gamepad.buttons[0].pressed || gamepad.buttons[1].pressed


        if (player.weapon && (gamepad.buttons[2].pressed ||  gamepad.buttons[3].pressed) && actionCooldown < timestamp-player.timeAtLastAction) {
          player.timeAtLastAction = timestamp;

          bullets = bullets.concat({x:player.x, y:player.y, dirX:player.dirX, dirY:player.dirY, math:player.weapon});
        }
      }

      for (let i = 0; i < swapWeaponPlayer.length; i++) {
        const element = swapWeaponPlayer[i];
        player = [p1, p2][i];

        if(!element){
          continue;
        }

        pickups.forEach(p => {
          const distance = dist(p.x, p.y, player.x, player.y)
          console.log(distance);
          if (actionCooldown < timestamp-player.timeAtLastAction && distance < pickupDistance) {
            player.timeAtLastAction = timestamp;
            console.log(p);
            [p.weapon, player.weapon] = [player.weapon, p.weapon];
            console.log(p);
          }
        });
      }


    }


    if (button['½']) {
      isIntro = true;
      global.startTime = Date.now()/1000;
      global = initState;
    }
    // ----------
    // Debug info
    {
      function f(o) {
        for (let key in o) {
          if("number" === typeof o[key]){
            o[key] = Math.round(o[key]*10)/10;
          } else if ("object" === typeof o[key]){
            f(o[key])
          }
        }
      }
      const tempGlobal = global;
      f(tempGlobal)

      t = JSON.stringify(global, null, 0);

      ctx.font = "11px Consolas"; // Sets tex
      ctx.fillText(t, 0, myCanvas.height-20)
      ctx.fillText(t.slice(45), 0, myCanvas.height-8)

      //ctx.drawImage(imgIntroDesk, 40, 40);
      //ctx.drawImage(imgLevelNotebook, 80, 80);

    }

    ctx.moveTo(0, 0);
    ctx.lineTo(s, s);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(s/2, s/2, s/2, 0, 2 * Math.PI);
    ctx.stroke();

    ctx.font = "50px Consolas"; // Sets text


    ctx.fillText("λ", p1.x+s/2, p1.y+s/2);
    ctx.fillText("β", p2.x+s/2, p2.y+s/2);

    [p1, p2].forEach(p=>{
      ctx.drawImage(imgHat2, -7+p.x+s/2, -60+p.y+s/2, 40, 40);
    })

    console.log(global.enemies);
    global.enemies = global.enemies.filter(e=>{
      // Movement logic
      const v = toUnit(e.x-p1.x, e.y-p1.y, 0, 0, e.speed)
      e.x += -e.speed*v[0]
      e.y += -e.speed*v[1]

      // Draw enemies
      ctx.fillText(e.math, e.x+s/2, e.y+s/2);

      for (let i = 0; i < 2; i++) {
        player = [p1, p2][i];
        console.log(player.lives);
        if (e.x-speed < player.x && e.x+speed > player.x &&
            e.y-speed < player.y && e.y+speed > player.y
        ){
          console.log(player);
          player.lives-=1;
          return false;
        }
      }
      return true;
    });

    bullets.forEach(b=>{
      ctx.font = "20px Consolas"; // Sets text
      ctx.fillText(b.math.math.toString(), b.x+s/2, b.y+s/2)
      ctx.font = "50px Consolas"; // Sets text
    })

    h = w = 78

    for(let i=0; i<2; i++){
      const player = [p1, p2][i]
      x = [20, s-w-20][i]
      ctx.beginPath();
      ctx.font = "23px Consolas"; // Sets text
      ctx.fillStyle = "lightgrey";
      ctx.fillRect(x, 20, w, h);
      ctx.stroke();

      ctx.beginPath();
      ctx.lineWidth = "4";
      ctx.strokeStyle = ["blue", "green"][i];
      ctx.rect(x, 20, w, h);
      ctx.stroke();

      ctx.beginPath();
      ctx.fillStyle = "red";
      if (player.lives>=1) ctx.fillText('♥︎', x, 41);
      if (player.lives>=2) ctx.fillText('♥︎', x+20, 41);
      if (player.lives>=3) ctx.fillText('♥︎', x+40, 41);
      ctx.stroke();

      if (player.weapon){
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.fillText(player.weapon.math, x+10, 80)
        console.log(player.weapon.math)
        ctx.stroke();
      }
    }

    localStorage.setItem("global", JSON.stringify(global));
    requestAnimationFrame(Draw);
  }
  requestAnimationFrame(Draw);

  document.onkeydown = function (e) {
    e = e || window.event; // Fixes internet explorer using "window.event" instead of the argument to the callback
    button[e.key] = true;
  };

  document.onkeyup = function (e) {
    e = e || window.event; // Fixes internet explorer using "window.event" instead of the argument to the callback
    button[e.key] = false;
  };

  // ---------------
  // Experiments
  // ---------------
  // let e = nerdamer('iz*(cos(x)+x*x)');
  // console.log(e.text());


</script>

</body>
</html>
